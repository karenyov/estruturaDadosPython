# -*- coding: utf-8 -*-
"""Algoritmos de ordenação.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_He185Pdm_29YGX5dkT6N3Wc_XqIx1ws

# Algoritmos de ordenação

## Bubble sort
"""

import numpy as np

def bubble_sort(vetor):
  n = len(vetor)

  for i in range(n):
    for j in range(0, n - i - 1):
      if vetor[j] > vetor[j + 1]:
        temp = vetor[j]
        vetor[j] = vetor[j + 1]
        vetor[j + 1] = temp
  return vetor

bubble_sort(np.array([15, 34, 8, 3]))

bubble_sort(np.array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))

"""## Selection sort"""

def selection_sort(vetor):
  n = len(vetor)

  for i in range(n):
    id_minimo = i
    for j in range(i + 1, n):
      if vetor[id_minimo] > vetor[j]:
        id_minimo = j
    temp = vetor[i]
    vetor[i] = vetor[id_minimo]
    vetor[id_minimo] = temp

  return vetor

selection_sort(np.array([15, 34, 8, 3]))

selection_sort(np.array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))

"""## Insertion sort"""

def insertion_sort(vetor):
  n = len(vetor)

  for i in range(1, n):
    marcado = vetor[i]

    j = i - 1
    while j >= 0 and marcado < vetor[j]:
      vetor[j + 1] = vetor[j]
      j -= 1
    vetor[j + 1] = marcado

  return vetor

insertion_sort(np.array([15, 34, 8, 3]))

insertion_sort(np.array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))

"""## Shell sort"""

def shell_sort(vetor):
  intervalo = len(vetor) // 2

  while intervalo > 0:
    for i in range(intervalo, len(vetor)):
      temp = vetor[i]
      j = i
      while j >= intervalo and vetor[j - intervalo] > temp:
        vetor[j] = vetor[j - intervalo]
        j -= intervalo
      vetor[j] = temp
    intervalo //= 2

  return vetor

shell_sort(np.array([15, 34, 8, 3]))

shell_sort(np.array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))

shell_sort(np.array([8,5,1,4,2,3]))

"""## Merge sort"""

def merge_sort(vetor):
  if len(vetor) > 1:
    divisao = len(vetor) // 2
    esquerda = vetor[:divisao].copy()
    direita = vetor[divisao:].copy()

    merge_sort(esquerda)
    merge_sort(direita)

    i = j = k = 0

    # Ordena esquerda e direita
    while i < len(esquerda) and j < len(direita):
      if esquerda[i] < direita[j]:
        vetor[k] = esquerda[i]
        i += 1
      else:
        vetor[k] = direita[j]
        j += 1
      k += 1

    # Ordenação final
    while i < len(esquerda):
      vetor[k] = esquerda[i]
      i += 1
      k += 1
    while j < len(direita):
      vetor[k] = direita[j]
      j += 1
      k += 1
  return vetor

merge_sort(np.array([15, 34, 8, 3]))

merge_sort(np.array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))

merge_sort(np.array([38, 27, 43, 3, 9, 82, 10]))

"""## Quick sort"""

def particao(vetor, inicio, final):
  pivo = vetor[final]
  i = inicio - 1

  for j in range(inicio, final):
    if vetor[j] <= pivo:
      i += 1
      vetor[i], vetor[j] = vetor[j], vetor[i]
  vetor[i + 1], vetor[final] = vetor[final], vetor[i + 1]
  return i + 1

def quick_sort(vetor, inicio, final):
  if inicio < final:
    posicao = particao(vetor, inicio, final)
    # Esquerda
    quick_sort(vetor, inicio, posicao - 1)
    # Direito
    quick_sort(vetor, posicao + 1, final)
  return vetor

vetor = np.array([15, 34, 8, 3])
quick_sort(vetor, 0, len(vetor) - 1)

vetor = np.array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])
quick_sort(vetor, 0, len(vetor) - 1)

"""## Comparativo entre algoritmos"""

import random
vetor = []
for _ in range(5000):
  vetor.append(round(random.random(), 4))

type(vetor)

vetor = np.array(vetor)
type(vetor)

vetor[:5]

len(vetor)

# Commented out IPython magic to ensure Python compatibility.
# %timeit bubble_sort(vetor.copy())

# Commented out IPython magic to ensure Python compatibility.
# %timeit selection_sort(vetor.copy())

# Commented out IPython magic to ensure Python compatibility.
# %timeit insertion_sort(vetor.copy())

# Commented out IPython magic to ensure Python compatibility.
# %timeit shell_sort(vetor.copy())

# Commented out IPython magic to ensure Python compatibility.
# %timeit merge_sort(vetor.copy())

# Commented out IPython magic to ensure Python compatibility.
# %timeit quick_sort(vetor.copy(), 0, len(vetor) - 1)

"""## Vetor ordenado"""

class VetorOrdenado:

  def __init__(self, capacidade):
    self.capacidade = capacidade
    self.ultima_posicao = -1
    self.valores = np.empty(self.capacidade, dtype=float)

  def insere(self, valor):
    if self.ultima_posicao == self.capacidade - 1:
      print('Capacidade atingida')
      return

    posicao = 0
    for i in range(self.ultima_posicao + 1):
      posicao = i
      if self.valores[i] > valor:
        break
      if i == self.ultima_posicao:
        posicao = i + 1

    x = self.ultima_posicao
    while x >= posicao:
      self.valores[x + 1] = self.valores[x]
      x -= 1

    self.valores[posicao] = valor
    self.ultima_posicao += 1

def insere_ordenado(valores):
  vetor = VetorOrdenado(len(valores))
  for i in range(len(valores)):
    vetor.insere(i)

# Commented out IPython magic to ensure Python compatibility.
# %timeit insere_ordenado(vetor.copy())